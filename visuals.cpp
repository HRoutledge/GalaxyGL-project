#include "visuals.h"

graphics::graphics() //default graphics contructor
{

}
	void graphics::installshaders()
	{
		//creating the shaders from shaderCode cpp
		VSOID = glCreateShader(GL_VERTEX_SHADER);
		FSOID = glCreateShader(GL_FRAGMENT_SHADER);

		const char* adapter[1];
		std::string temp = readshadercode("VertexShaderCode.glsl");
		adapter[0] = temp.c_str();
		glShaderSource(VSOID, 1, adapter, NULL);
		temp = readshadercode("FragmentShaderCode.glsl");
		adapter[0] = temp.c_str();
		glShaderSource(FSOID, 1, adapter, NULL);

		glCompileShader(VSOID);
		glCompileShader(FSOID);

		//check that program & shaders are healthy
		if (!checkshaderandprogramstatus(VSOID, FSOID, programID))
			return;

		programID = glCreateProgram();
		glAttachShader(programID, VSOID);
		glAttachShader(programID, FSOID);
		glLinkProgram(programID);
		glDeleteShader(VSOID);
		glDeleteShader(FSOID);
		glUseProgram(programID);
	}

	bool graphics::checkshaderandprogramstatus(GLuint shaderID, GLuint shaderID2, GLuint programID)
	{
		/*this method checks for and errors when compiling shaders & program*/

		int  Ssuccess, Ssuccess2, Psuccess;
		char infoLog[512], infoLog2[512], infoLog3[512];
		glGetShaderiv(shaderID, GL_COMPILE_STATUS, &Ssuccess);

		if (!Ssuccess)
		{
			glGetShaderInfoLog(shaderID, 512, NULL, infoLog);
			std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
			return false;
		}

		glGetShaderiv(shaderID2, GL_COMPILE_STATUS, &Ssuccess2);

		if (!Ssuccess)
		{
			glGetShaderInfoLog(shaderID2, 512, NULL, infoLog2);
			std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog2 << std::endl;
			return false;
		}

		glGetShaderiv(programID, GL_COMPILE_STATUS, &Psuccess);

		if (!Psuccess)
		{
			glGetShaderInfoLog(programID, 512, NULL, infoLog3);
			std::cout << "ERROR::PROGRAM::COMPILATION_FAILED\n" << infoLog3 << std::endl;
			return false;
		}
		return true;
	}

	std::string graphics::readshadercode(const char* filename)
	{
		/*this method is used to read the vertex & fragment glsl shader code files*/

		std::ifstream thisinput(filename);
		if (!thisinput.good())
		{
			std::cout << "could no load file" << filename;
			exit(1);
		}
		return std::string(
			std::istreambuf_iterator<char>(thisinput),
			std::istreambuf_iterator<char>());
	}



	galaxy::galaxy() //default galaxy constructor
	{
	
	}

	void galaxy::setprimarycolor()
	{

		/*this method sets the initial base colour of the galaxy*/

		int rg = lerandfunc(1, 4); //basically rolling a die
		std::cout << rg << std::endl;

		switch (rg)
		{
		case 1:
			r = lerandfunc(0.375f, 0.95f);
			g = lerandfunc(0.1f, 0.25f);
			b = lerandfunc(0.1f, 0.35f);
			break;
		case 2:
			r = lerandfunc(0.01f, 0.1f);
			g = lerandfunc(0.55f, 1.0f);
			b = lerandfunc(0.2f, 0.3f);
			break;
		case 3:
			r = lerandfunc(0.1f, 0.5f);
			g = lerandfunc(0.1f, 0.2f);
			b = lerandfunc(0.65f, 1.0f);
			break;

		}
	}

	int galaxy::getSOA()
	{
		return sizeOfArray;
	}

	void galaxy::makegalaxy()
	{
		//this method draws the galaxy shape

		const float mypi = 2.0f * acos(0.0f); //define pi
		int numarms = rand() % 6 + 3; //set number of desired 'arms'
		const float armsepdist = 2.0f * mypi / numarms; 
		float armoffsetmax = lerandfunc(0.2f, 0.75f);
		float rotfactor = lerandfunc(3.5f, 6.5f);

		float randxyoffset = lerandfunc(0.03f, 0.06f);
		for (int i = 0; i < sizeOfArray; i++) //sizeofarray = amount of points that make up galaxy
		{
			float distance = lerandfunc(0.0f, 1.0f);
			distance = pow(distance, 2);
			float invdist;
			invdist = distance * -1;
			float angle = lerandfunc(0.0f, 1.0f) * 2.0f * mypi;
			float armoffset = lerandfunc(0.0f, 1.0f) * armoffsetmax;
			armoffset = armoffset - armoffsetmax / 2.0f;
			armoffset = armoffset * (1.0f / distance);

			float armoffsetsqrd = pow(armoffset, 2);
			if (armoffset < 0)
				armoffsetsqrd = armoffsetsqrd * -1;
			armoffset = armoffsetsqrd;
			float rotation = distance * rotfactor;
			angle = (int)(angle / armsepdist) * armsepdist + armoffset + rotation;

			float starX = cos(angle) * distance;
			float starY = sin(angle) * distance;

			float randomOffsetX = lerandfunc(0.0f, 1.0f) * randxyoffset;
			float randomOffsetY = lerandfunc(0.0f, 1.0f) * randxyoffset;

			starX += randomOffsetX;
			starY += randomOffsetY;

			/*use float data generated by allgorithm as position data for openGL*/
			pCloud[i].position.x = starX;
			pCloud[i].position.y = starY;
			pCloud[i].position.z = pow(lerandfunc(-0.4f, 0.4f), 3);
			pCloud[i].col = glm::vec3(lerandfunc(0.66f, 1.0f), lerandfunc(0.3f, 0.825f), lerandfunc(0.7f, 1.0f)) * glm::vec3(pow(invdist, -2) / lerandfunc(2, 3), pow(invdist, -2) / lerandfunc(2, 3), pow(invdist, -2) / 2);

		}

	}
